import importlib
import logging
from typing import Dict, List

from .base import BasePlugin
from . import discover_plugins, registered_plugins
from config.settings import settings

logger = logging.getLogger(__name__)

class PluginManager:
    def __init__(self, config, db, router):
        self.config = config
        self.db = db
        self.router = router
        self.plugins: Dict[str, BasePlugin] = {}

    async def discover_and_load(self):
        """Discover via entry‑points, instantiate, and call init()."""
        self.plugins = {}
        for name, cls in discover_plugins().items():
            plugin = cls(self.config, self.db, self.router)
            await plugin.init()
            self.plugins[name] = plugin
            registered_plugins[name] = plugin
        logger.info(f"Loaded plugins: {list(self.plugins.keys())}")

    async def shutdown_all(self):
        for plugin in self.plugins.values():
            await plugin.shutdown()

    # ------------------------------------------------------------------ #
    # Helper APIs used by the core app
    # ------------------------------------------------------------------ #
    @property
    def status(self) -> dict:
        """Return a consolidated status dict for all plugins."""
        return {
            name: {
                "version": p.version,
                "enabled": True,
                "tools": p.tools,
                "commands": p.commands,
            }
            for name, p in self.plugins.items()
        }

    def list_commands(self) -> List[dict]:
        cmds = []
        for p in self.plugins.values():
            for c in p.commands:
                cmds.append({"plugin": p.name, **c})
        return cmds

    async def handle_command(self, name: str, args: str):
        """Dispatch a slash‑command to the owning plugin."""
        for p in self.plugins.values():
            for cmd in p.commands:
                if cmd["name"] == name:
                    return await p.run(args)
        return None

    async def process_tool_calls(self, content: str):
        """Detect <tool_call> tags and invoke the correct plugin tool."""
        # Simple regex extraction – can be upgraded later
        import re
        pattern = r"<tool_call>(\w+):(\w+)\((.*?)\)</tool_call>"
        results = []
        for match in re.finditer(pattern, content):
            plugin_name, tool_name, raw_params = match.groups()
            plugin = self.plugins.get(plugin_name)
            if not plugin:
                results.append({"tool": tool_name, "error": f"Plugin {plugin_name} not found"})
                continue
            # Parse parameters (key=value, comma separated)
            params = {}
            for pair in re.split(r",\s*(?=\w+=)", raw_params):
                if "=" in pair:
                    k, v = pair.split("=", 1)
                    params[k.strip()] = v.strip().strip("\"'")
            try:
                res = await getattr(plugin, f"tool_{tool_name}")(**params)
                results.append({"tool": tool_name, "result": res})
            except Exception as exc:
                results.append({"tool": tool_name, "error": str(exc)})
        return results